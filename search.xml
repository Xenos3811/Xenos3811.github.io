<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F2019%2F06%2F23%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[测试001]]></content>
  </entry>
  <entry>
    <title><![CDATA[Angular中的路由]]></title>
    <url>%2F2019%2F01%2F11%2FAngular%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[Angular中的路由(router)使用angular-cli创建 router项目 –routing创建两个组件(home,product)12ng -g new homeng -g new product 在Angular中配置路由在app-routing.module.ts中配置Routes路由配置1234567891011121314151617import &#123; NgModule &#125; from '@angular/core';import &#123; Routes, RouterModule &#125; from '@angular/router';import &#123;HomeComponent&#125; from './home/home.component';import &#123;ProductComponent&#125; from './product/product.component';import &#123;Code404Component&#125; from './code404/code404.component';const routes: Routes = [ &#123;path: '', component: HomeComponent&#125;, &#123;path: 'product', component: ProductComponent&#125;, &#123;path: '**', component: Code404Component&#125;];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123; &#125; 在Angular中使用路由 通过routerLink进行路由示例: 12&lt;!-- 通过routerLink 进行导航 --&gt;&lt;a [routerLink]="['/']"&gt;主页&lt;/a&gt;&lt;br&gt; 通过onclick事件进行路由1.定义button按钮 1&lt;input type="button" value="商品详情" (click)="toProductDetails()" /&gt; 2.声明toProductDetails事件 12toProductDetails() &#123;&#125; 3.在构造函数中注入Router对象 123// 通过构造函数获取对象constructor(public router: Router) &#123;&#125; 4.在toProductDetails中进行路由 123toProductDetails() &#123; this.router.navigate(['/product']);&#125; 在路由中传递参数 使用queryParams绑定路由参数(http://****?id=1)示例:绑定并传递参数12&lt;!-- queryParams 路由传递参数 --&gt;&lt;a [routerLink]="['/product']" [queryParams]="&#123;id: 1&#125;"&gt;商品详情&lt;/a&gt;&lt;br&gt; 示例:接收参数在productComponent组件中通过构造方法注入Router路由对象.通过ngOnInit方法中,通过Router获取参数并绑定productId属性12345678private productId: number; // 通过构造方法可以获取 router 路由对象. constructor(private routInfo: ActivatedRoute) &#123; &#125; ngOnInit() &#123; // 通过路由快照获取 id 参数 this.productId = this.routInfo.snapshot.queryParams['id']; &#125; 在路由中通过url传递参数(http://****/1)修改Angular路由配置/:id1&#123;path: 'product/:id', component: ProductComponent&#125;, 通过routerLink路由直接传递参数1&lt;a [routerLink]="['/product',1]" &gt;商品详情&lt;/a&gt;&lt;br&gt; ProductComponent中使用params方法获取url上的参数1234ngOnInit() &#123; // 通过路由快照获取 id 参数 this.productId = this.routInfo.snapshot.params['id']; &#125; 路由中的参数快照与参数订阅在上面例子中可以看到,获取参数的值得调用方法如下(即参数快照):12// 这里是使用snapshot快照形式获取的 id 参数. 因为在ngOninit方法中,该赋值操作只执行一次,导致若oldPage与newPage是同一路由情况下,参数一直为oldPage上的参数.this.routInfo.snapshot.params['id']; 还有一种参数订阅的方式也能获取传递进来的参数(即参数订阅),如下:12// 这里使用subscribe订阅了传递参数属性,后进行赋值.可以解决参数快照出现的问题this.routInfo.params.subscribe((params: Params) =&gt; this.productId = params['id']); 重定向路由需求:访问主页时,路由到homeComponent组件下.在项目路由配置中添加如下配置:1&#123;path: '', redirectTo: 'home', pathMatch: 'full'&#125;, 子路由 配置子路由(主要是route中的children属性) 1234567&#123;path: 'product/:id', component: ProductComponent, children : [ &#123;path: '', redirectTo: 'product-desc', pathMatch: 'full'&#125;, &#123;path: 'product-desc', component: ProductDescComponent&#125;, &#123;path: 'sale/:id', component: SalerComponent &#125; ] &#125; 调用子路由 12&lt;a [routerLink]="['./product-desc']" &gt;商品描述&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a [routerLink]="['./sale',3]" &gt;销售员id&lt;/a&gt; 辅助路由(自定义路由) 在主模板声明自定义路由插座 1&lt;router-outlet name="aux"&gt;&lt;/router-outlet&gt; 配置自定义路由(autle:&#39;aux&#39;) 12// outlet 属性映射为路由插座名称 配置一下属性表示该路由仅在aux插座生效 &#123;path: 'chat', component: ChatComponent , outlet: 'aux'&#125;, 使用自定义路由 123// 通过outlets指定路由, [&#123;outlets:&#123;'插座名称':'路由名称'&#125;&#125;]&lt;a [routerLink]="[&#123;outlets: &#123;aux: 'chat'&#125;&#125;]" &gt;开始聊天&lt;/a&gt;&amp;nbsp;&lt;a [routerLink]="[&#123;outlets: &#123;aux: null&#125;&#125;]" &gt;结束聊天&lt;/a&gt;&amp;nbsp; 设置主路由跟随(primary) 1&lt;a [routerLink]="[&#123;outlets: &#123;primary: 'home', aux: 'chat'&#125;&#125;]" &gt;开始聊天&lt;/a&gt;&amp;nbsp; 路由守卫 CanActivate: 处理导航到某路由的情况 CanDeactivate: 处理从当前路由离开的情况 Resolve: 在路由激活之前获取路由数据 使用路由守卫 使用CanActivate: 路由到后执行创建守卫类型,实现CanActivate接口 12345678910import &#123;CanActivate&#125; from '_@angular_router@7.2.0@@angular/router';export class LoginGuard implements CanActivate &#123; canActivate() &#123; const loggedIn: boolean = Math.random() &lt; 0.5 ; if (!loggedIn) &#123; console.info('用户未登录'); &#125; return loggedIn; &#125;&#125; 在路由中注册路由守卫:别忘了注入守卫实现类: 使用CanDeactivate: 路由离开时执行实现CanDeactivate接口,并注册路由守卫… 使用Resolve: 路由到前执行 (可用于做路由跳转前赋值操作)示例:创建product.resolve.ts,实现Relove&lt;返回对象类型&gt;接口.返回一个对象.12345678910111213141516171819@Injectable()export class ProductResolve implements Resolve&lt;Product&gt; &#123; constructor(private router: Router) &#123; &#125; resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;Product&gt; | Promise&lt;Product&gt; | Product &#123; let productId: number = route.params['id']; if (productId == 1) &#123; return new Product(1,"iphoneX"); &#125;else &#123; this.router.navigate(['/home']); return undefined; &#125; return undefined; &#125;&#125; 注意事项:自定义Resolve必须添加@Injectable()注解…只有被此装饰器注解,才能依赖注入在路由配置中配置前置路由resolve]]></content>
      <categories>
        <category>Augular</category>
      </categories>
      <tags>
        <tag>Angular路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MQTT初体验]]></title>
    <url>%2F2019%2F01%2F04%2FMQTT%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[简介 MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的轻量级协议，该协议构建于TCP/IP协议之上，MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。 MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。 因此,MQTT需要一个消息服务中间件 特性MQTT协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性： 使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。 对负载内容屏蔽的消息传输。 使用TCP/IP提供网络连接。主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。 有三种消息发布服务质量:“至多一次”，消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。“至少一次”，确保消息到达，但消息重复可能会发生。“只有一次”，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。 小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量。这就是为什么在介绍里说它非常适合“在物联网领域，传感器与服务器的通信，信息的收集”，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。 搭建MQTT消息中间件(emq)]]></content>
      <categories>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>emq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维码生成解析器]]></title>
    <url>%2F2018%2F12%2F27%2F%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E8%A7%A3%E6%9E%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[使用qrcode-utils引入依赖123456&lt;!-- 二维码生成器--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.binarywang&lt;/groupId&gt; &lt;artifactId&gt;qrcode-utils&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt;&lt;/dependency&gt; springboot 项目代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@SpringBootApplication@RestController@Slf4j@Getter@Setterpublic class QrcodeApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(QrcodeApplication.class, args); &#125; @GetMapping("/get") public String getQrCode(HttpServletResponse response) throws IOException, NotFoundException &#123; User user = new User("1", "571482631", "8961442xjc", 14, "13545675772"); String json = JSON.toJSONString(user);// byte[] qrcode = QrcodeUtils.createQrcode(json, null); byte[] qrcode = QrcodeUtils.createQrcode(json, new File("G:\\upload\\icon.jpg")); ByteArrayInputStream in = new ByteArrayInputStream(qrcode); //将qrcode作为输入流； BufferedImage image = ImageIO.read(in);// 写到文件上 ImageIO.write(image, "JPEG", new FileImageOutputStream(new File("G:\\upload\\recode.jpg")));// 解析二维码 String decode = QrcodeUtils.decodeQrcode(new File("G:\\upload\\recode.jpg")); log.info("decode:" + decode);// 写到浏览器上 ImageIO.write(image, "JPEG", response.getOutputStream()); return "hello"; &#125; @Setter @Getter public class User &#123; private String id; private String username; private String password; private Integer age; private String phone; public User(String id, String username, String password, Integer age, String phone) &#123; this.id = id; this.username = username; this.password = password; this.age = age; this.phone = phone; &#125; &#125;&#125; 二维码浏览]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>二维码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用spring-aop处理自定义注解]]></title>
    <url>%2F2018%2F12%2F18%2F%E4%BD%BF%E7%94%A8spring-aop%E5%A4%84%E7%90%86%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[AOP概念: 面向侧面的程序设计（aspect-oriented programming，AOP，又译作面向方面的程序设计、观点导向编程、剖面导向程序设计）是计算机科学中的一个术语，指一种程序设计范型。该范型以一种称为侧面（aspect，又译作方面）的语言构造为基础，侧面是一种新的模块化机制，用来描述分散在对象、类或函数中的横切关注点（crosscutting concern）。 在springboot中使用aop处理自定义注解 依赖文件 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- AOP依赖模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; 处理一个http请求. 1234567891011@RestController@RequestMapping("/")public class HelloWordController &#123; @Autowired private HelloWordService service; @GetMapping("hello") public String hello(String name)&#123; return service.sayHello(name); &#125;&#125; service层 12345678@Servicepublic class HelloWordService &#123; public String sayHello(String name)&#123; return "hello"+ Optional.ofNullable(name).orElse(" World !"); &#125;&#125; 自定义注解 12345678910/** * @author: xjc * @date 2018/12/18 9:18 * @description 自定义注解 **/@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String note() default "";&#125; 编写一个切面 123456789101112131415161718192021222324252627282930313233/** * @author: xjc * @date 2018/12/18 9:19 * @description **/@Aspect@Component@Slf4jpublic class MyAspact &#123; ThreadLocal&lt;Long&gt; beginTime = new ThreadLocal&lt;&gt;(); // 定义切入点 @Pointcut("@annotation(annotation)") public void log(MyAnnotation annotation)&#123; &#125; @Before("log(annotation)") public void doBefore(JoinPoint joinPoint, MyAnnotation annotation) &#123; // 记录请求到达时间 beginTime.set(System.currentTimeMillis()); log.info("cy666 note:&#123;&#125;", annotation.note()); Object aThis = joinPoint.getThis(); Object[] args = joinPoint.getArgs(); String kind = joinPoint.getKind(); Object target = joinPoint.getTarget(); &#125; @After("log(annotation)") public void doAfter(MyAnnotation annotation) &#123; log.info("cy666 statistic time:&#123;&#125;, note:&#123;&#125;", System.currentTimeMillis() - beginTime.get(), annotation.note()); &#125;&#125; 为service方法填加注解启动测试.查看控制台:]]></content>
      <categories>
        <category>spring-boot</category>
      </categories>
      <tags>
        <tag>spring-aop处理自定义注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Security-Acl:细粒度权限控制]]></title>
    <url>%2F2018%2F12%2F16%2FSpring-Security-Acl-%E7%BB%86%E7%B2%92%E5%BA%A6%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[简介: Spring ACL有助于在单个域对象上定义特定用户/角色的权限 - 而不是在典型的每个操作级别上全面定义权限。因此，不同的用户/角色对每个特定对象具有不同的权限。在这种情况下，Spring ACL能够完成任务 ACL databases (ACL数据库模型) ACL_CLASS ACL_SID ACL_IDENTITY ACL_ENRTY ACL_CLASS (资源对象)which store class name of the domain object (资源实体对象) ID:CLASS: 指向资源实体的类名,例如: org.baeldung.acl.persistence.entity.NoticeMessage ACL_SID: (授权对象)which allows us to universally identify any principle or authority in the system (权限拥有者,USER OR ROLE)ID:SID: 用户或者角色的IDPRINCIPAL:0 or 1 to indicate that the corresponding SID is a principal (user, such as mary, mike, jack…) or an authority (role, such as ROLE_ADMIN, ROLE_USER, ROLE_EDITOR…) 用来表示当前行数据是一个用户,还是一个角色类型 ACL_OBJECT_IDENTITY: (定义了一个唯一的资源对象与资源所有者)ID:OBJECT_ID_CLASS: 对应资源实体的iDOBJECT_ID_IDENTITY:domain objects can be stored in many tables depending on the class. Hence, this field store the target object primary key也就是说,一个类的定义在表中可以存在多个实例,这个键存的就是对应表中其中一行的主键.(以上三个字段就定义了一个唯一的资源&lt;唯一的某个数据&gt;) OWNER_SID: 对应权限所有者的ID (以上定义了一个完整的数据资源以及资源的所有者) PARENT_OBJECT: 父节点ID,形成树形结构, 若存在父节点,父级节点授权后,通过下面这个字段的标识,决定是否授权此项 ENTRIES_INHERITTING: whether ACL Entries of this object inherits from the parent object (ACL Entries are defined in ACL_ENTRY table 是否允许父类授权后是否授权此项 ACL_ENTRY: (最主要的表,表示一个唯一的资源是否允许被一个USER OR ROLE 进行何种操作)ID:ACL_OBJECT_IDENTITY: 权限项 (包含唯一资源与其所有者)ACL_ORDER: 授权顺序SID: 所有者(ROLE OR User) 该访问者MASK: the integer bit mask that represents the actual permission being granted or denied (操作隐码&lt;1默认是读,2默认是写&gt;,具体参考BasePermission.class)GRANTING: value 1 means granting, value 0 means denying 是否允许授权AUDIT_SUCCESS AND AUDIT_FAILURE: for auditing purpose (计数?暂时不知道其作用) DEMODEMO 测试: 在Dao层添加数据访问权限注解 1234567891011public interface NoticeMessageDao extends JpaRepositoryImplementation&lt;NoticeMessage ,Long&gt; &#123; @PostFilter("hasPermission(filterObject, 'READ')") List&lt;NoticeMessage&gt; findAll(); @PostAuthorize("hasPermission(returnObject, 'READ')") NoticeMessage findById(Integer id); @PreAuthorize("hasPermission(#noticeMessage, 'WRITE')") NoticeMessage save(@Param("noticeMessage") NoticeMessage noticeMessage);&#125; @PostFilter : 意为只返回该User用户具有的所有的只读的NoticeMessage.@PostAuthorize : 意为返回该User对此资源对象是否具有只读权限,有则返回,无则报错.@PreAuthorize 意为该User对此资源对象是否拥有写操作,若有,则允许方法进行,若无,则报错 测试 使用manager用户查询所有message Message表中的假数据: 首先运行测试方法查看效果: 仅仅只查询出来两条数据.有点不信(因为acl默认帮我们实现了一系列操作).注释掉注解,继续测试: 看到,实际可以查出三条数据 ACL实现分析:产生上面测试原因的主要原因:是在acl_enrty表中拥有一条记录ACL_ENTYR (简称权限条目表)(一个唯一的资源是否允许一个唯一的角色或者用户拥有何种操作)这样一看有点懵.首先看标记的两条的SID 属性,这里定义了一个角色OR用户.观察acl_sid表. 角色用户定义表: 这里正好定义了一个manager用户反看entry表中,Identity 为1与3Identity表数据这里可以得知: object_id_identity 字段对应的是在message表中的主键字段,其实就是定义了唯一的资源这样一个唯一资源(identity表中定义)的所有者(entry表中定义)的包含操作(entry表中定义)就有了.拥有这些属性就可以进行权限校验了重新梳理一遍就不难知道acl是如何做到数据级别的权限控制了 ACL流程分析:在dao层加入注解后,当访问该方法时,acl会通过方法返回值的对像(若没有返回值,可以指定一个对象,.&lt;在acl_class表中定义的&gt;)与当前登录用户的username和其角色信息查询到所具有的操作权限,若通过则允许该方法执行,若不通过,则报错.具体的查询流程: (个人猜测,暂时没看源码) 通过所有class查询 acl_class中的id 通过class中的id过滤所有identity.得到identity ids 通过 user 查询所有的sid 通过identity ids与 user sid 过滤所有entry 最后得出的那些.entry进行权限校验 问题: 在acl_identity表中的owner_sid 有什么作用?个人认为identity表中sid与entry表中sid重复了. 在上面的测试中可以看到 owner_sid 全是3. 没有1.但是在entry中定义了资源的控制.并且也成功了,(之前想过用来简化筛选,但是这并没有简化啊.)]]></content>
      <categories>
        <category>spring-security</category>
      </categories>
      <tags>
        <tag>ACL访问控制列表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于OAuth2开发Client模块]]></title>
    <url>%2F2018%2F12%2F16%2F%E5%9F%BA%E4%BA%8EOAuth2%E5%BC%80%E5%8F%91Client%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[(自己实现@EnableOAuth2Sso 注解,任何基于springSecurity权限的子系统引入该模块后,可自动实现在认证服务器认证及授权操作,完成本地认证授权.&lt;由认证服务器实现SSO&gt;) 项目构建 目录结构 jar包依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.M3&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--druid--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--MySQL Driver--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-jwt&lt;/artifactId&gt; &lt;version&gt;1.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.54&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-beanutils/commons-beanutils --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; &lt;version&gt;1.9.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; 构建OAuth2RestOperations用于向认证服务器获取token 构建图: 代码实现 (仅实现了password模式与code模式)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/*** @author:xjc* @date:2018/12/6* @description: 调用Oauth所需要资源信息* @params:*/@Beanpublic OAuth2ProtectedResourceDetails getOAuth2ProtectedResourceDetails()&#123; ProtectedResourceProperties resource = clientProperties.getResource(); if(GlobalConstant.RESOURCE_GRAND_TYPE_PASSWORD.equals(clientProperties.getResource().getGrantType()))&#123; ResourceOwnerPasswordResourceDetails protectedDetails = new ResourceOwnerPasswordResourceDetails(); try &#123; setProperty(protectedDetails,resource); &#125; catch (Exception e) &#123; log.warn("请配置该有项"); &#125; return protectedDetails; &#125;else &#123;// 授权码模式 AuthorizationCodeResourceDetails protectedDetails = new AuthorizationCodeResourceDetails(); try &#123; setProperty(protectedDetails,resource); protectedDetails.setUserAuthorizationUri(resource.getAuthorizationUri()); log.info(protectedDetails.getPreEstablishedRedirectUri()); protectedDetails.setUseCurrentUri(false);// 必须设置.回调url protectedDetails.setPreEstablishedRedirectUri(clientProperties.getContextPath()+clientProperties.getLogin().getLoginPage()); // protectedDetails.setUseCurrentUri(true); &#125; catch (Exception e) &#123; log.warn("请配置该有项"); &#125; return protectedDetails; &#125;&#125;/** * @author:xjc * @date:2018/12/11 * @description:设置认证服务器属性 * @params: */protected &lt;T extends BaseOAuth2ProtectedResourceDetails&gt; T setProperty(T protectedDetails,ProtectedResourceProperties resource)&#123; protectedDetails.setAccessTokenUri(resource.getAccessTokenUrl()); protectedDetails.setClientId(clientProperties.getClientId()); protectedDetails.setClientSecret(clientProperties.getClientSecret()); protectedDetails.setScope(Arrays.asList(resource.getScope().split(","))); return protectedDetails;&#125;@Beanpublic OAuth2RestTemplate oauth2RestTemplate() &#123; OAuth2ProtectedResourceDetails details = getOAuth2ProtectedResourceDetails();// 构建template OAuth2RestTemplate template;// 设置template中的AccessToken /** * @author:xjc * @description: 若不设置AccessTokenProvider.会采用默认的AccessTokenProviderChain 这个默认的提供器会判断请求源是否经过本地认证, 否 则抛出异常,然后跳到本地登录页面(默认) 但是我们要做的就是认证,所以直接设置该有的token提供器就会跳过 默认的判断 */ if(details instanceof ResourceOwnerPasswordResourceDetails)&#123; template = new OAuth2RestTemplate(details, new DefaultOAuth2ClientContext()); template.setAccessTokenProvider(new ResourceOwnerPasswordAccessTokenProvider()); return template; &#125; if(details instanceof AuthorizationCodeResourceDetails)&#123; /** * @author:xjc * @date:2018/12/7 * @description: 这里必须new一个ClientContext对象, 内部使用动态代理存储state,若使用默认,则state会找不到 */ template = new OAuth2RestTemplate(details, new DefaultOAuth2ClientContext());//new DefaultOAuth2ClientContext()// template = new OAuth2RestTemplate(details, oauth2ClientContext); template.setAccessTokenProvider(new AuthorizationCodeAccessTokenProvider()); return template; &#125; throw new RuntimeException("请配置客户端相关属性");&#125; 定义User接口,获取token12345678910public interface UserService &#123; OAuth2AccessToken getToken(String str_key, String str_value); User getUserInfo(OAuth2AccessToken token) throws InvocationTargetException, IllegalAccessException; Authentication getAuthentication(User user); String getRedirectUri();&#125; 认证流程图: 代码实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Autowired private OAuth2RestTemplate oAuth2RestTemplate; @Autowired private ClientProperties properties; private ObjectMapper mapper = new ObjectMapper(); @Override public OAuth2AccessToken getToken(String s1, String s2) &#123; OAuth2ProtectedResourceDetails resource = oAuth2RestTemplate.getResource(); if(resource instanceof ResourceOwnerPasswordResourceDetails)&#123; ResourceOwnerPasswordResourceDetails resourceDetails = (ResourceOwnerPasswordResourceDetails) resource; resourceDetails.setUsername(s1); resourceDetails.setPassword(s2);// 获取当前session认证信息// Authentication auth = SecurityContextHolder.getContext().getAuthentication(); return oAuth2RestTemplate.getAccessToken(); &#125; if(resource instanceof AuthorizationCodeResourceDetails)&#123; OAuth2ClientContext context = oAuth2RestTemplate.getOAuth2ClientContext(); /** * 判断s1 state是否有值.若没有值,判断context中是否有值, 有则放,没有则清空,(重要) * * */ if(StringUtils.isEmpty(s1))&#123; String key = context.getAccessTokenRequest().getStateKey(); if(StringUtils.isNotEmpty(key)) context.getAccessTokenRequest().setStateKey(null); &#125; /** * 若为带参数请求.则设置code值. *******重要******** * code模式默认使用jdk动态代理开启另一个线程调用, * */ if(s2!=null) context.getAccessTokenRequest().setAuthorizationCode(s2); return oAuth2RestTemplate.getAccessToken(); &#125; throw new RuntimeException("请先完成配置项");&#125; 加入LoginFliter拦截器,在请求访问时进行拦截认证定义LoginFilter 继承 OncePerRequestFilter]]></content>
      <categories>
        <category>spring-security</category>
      </categories>
      <tags>
        <tag>oauth2-client</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Spring-Socail开发第三方认证]]></title>
    <url>%2F2018%2F12%2F16%2F%E4%BD%BF%E7%94%A8Spring-Socail%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%89%E6%96%B9%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[整体流程图: 主要依赖123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.springframework.social&lt;/groupId&gt; &lt;artifactId&gt;spring-social-core&lt;/artifactId&gt; &lt;version&gt;2.0.0.M4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.social&lt;/groupId&gt; &lt;artifactId&gt;spring-social-config&lt;/artifactId&gt; &lt;version&gt;2.0.0.M4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.social&lt;/groupId&gt; &lt;artifactId&gt;spring-social-security&lt;/artifactId&gt; &lt;version&gt;2.0.0.M4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.social&lt;/groupId&gt; &lt;artifactId&gt;spring-social-web&lt;/artifactId&gt; &lt;version&gt;2.0.0.M4&lt;/version&gt;&lt;/dependency&gt; 构建ServiceProvider(服务器提供商)1.构建OAuth2Operations对象(获取token对象)创建QQOAuth2Template继承OAuth2Template由于QQ返回响应不是标准json格式,需重写解析逻辑 在构造函数中设置 setUseParametersForClientAuthentication(true) ps:默认为false,发起请求时没有携带clientID与clientSecret 属性.设置为true. 重写createRestTemplate ,使template对象可以解析返回字符串.默认仅能解析json或form表单. 重写 postForAccessGrant 方法,自定义解析响应逻辑(因为QQ授权返回的token是在url上的,需要自己解析,没有默认实现) 12345678910111213141516171819202122232425262728293031323334353637383940414243@Slf4jpublic class QQOAuth2Template extends OAuth2Template &#123; public QQOAuth2Template(String clientId, String clientSecret, String authorizeUrl, String accessTokenUrl) &#123; super(clientId, clientSecret, authorizeUrl, accessTokenUrl);// 设置为true.template发送请求时才会携带 clientId 与clientSecret..(重要) setUseParametersForClientAuthentication(true); &#125; @Override protected RestTemplate createRestTemplate() &#123; RestTemplate template = super.createRestTemplate(); // social原本不会解析字符串,只会解析form或者json格式数据,添加此项 //可以解析返回字符串 template.getMessageConverters().add(new StringHttpMessageConverter(Charset.forName("UTF-8"))); return template; &#125; /** * @author:xjc * @date:2018/12/1 * @description: 由于QQ返回响应为string类型的参数字符串,不是json数据,social无法自己解析,需重写方法自定义解析 * @params: */ @Override protected AccessGrant postForAccessGrant(String accessTokenUrl, MultiValueMap&lt;String, String&gt; parameters) &#123; String responseStr=getRestTemplate().postForObject(accessTokenUrl,parameters,String.class); log.info("获取accessToken的响应:"+responseStr); String[] items=responseStr.split("&amp;"); String accessToken = items[0].substring(items[0].indexOf("=")+1); log.info("accessToken:"+accessToken); Long expiresIn = new Long(items[1].substring(items[1].indexOf("=")+1)); log.info("expiresIn:"+expiresIn); String refreshToken = items[2].substring(items[2].indexOf("=")+1); log.info("refreshToken:"+refreshToken); return new AccessGrant(accessToken,null,refreshToken,expiresIn); &#125;&#125; 2.构建API (用户封装token换取的第三方用户信息)创建QQApi 实现 继承AbstractOAuth2ApiBinding 类,重写getUserInfo方法使用getRestTemplate可以向第三方应用发送请求并获取响应信息.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Getter@Setter@Slf4jpublic class QQImpl extends AbstractOAuth2ApiBinding implements QQ &#123;// 获取用户openId的url private static final String URL_GET_OPENID = "https://graph.qq.com/oauth2.0/me?access_token=%s";// 获取用户信息的 url private static final String URL_GET_USER_INFO = "https://graph.qq.com/user/get_user_info?oauth_consumer_key=%s&amp;openid=%s"; private String appId; private String openId; private ObjectMapper objectMapper = new ObjectMapper(); public QQImpl(String accessToken , String appId)&#123; super(accessToken, TokenStrategy.ACCESS_TOKEN_PARAMETER); this.appId=appId; String url = String.format(URL_GET_OPENID,accessToken); String openid_result=getRestTemplate().getForObject(url,String.class); log.info("openid_result::::::"+openid_result); String openid=StringUtils.substringBetween(openid_result,"\"openid\":\"","\"&#125;"); this.openId = openid; &#125; @Override public QQUserInfo getQQUserInfo() &#123; String user_info_url = String.format(URL_GET_USER_INFO,appId,openId); String user_info_result=getRestTemplate().getForObject(user_info_url,String.class); log.info("user_info_result:::"+user_info_result); try &#123; QQUserInfo userInfo = objectMapper.readValue(user_info_result, QQUserInfo.class); userInfo.setOpenId(openId); return userInfo; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 3.通过template与api构建provider123456789101112131415161718public class QQServiceProvider extends AbstractOAuth2ServiceProvider&lt;QQ&gt; &#123; private String appId; private static final String URL_AUTHOREIZE = "https://graph.qq.com/oauth2.0/authorize"; private static final String URL_ACCESS_TOKEN = "https://graph.qq.com/oauth2.0/token"; public QQServiceProvider(String appId,String appSecret) &#123; super(new QQOAuth2Template(appId,appSecret,URL_AUTHOREIZE,URL_ACCESS_TOKEN)); this.appId=appId; &#125; @Override public QQ getApi(String accessToken) &#123; return new QQImpl(accessToken,appId); &#125;&#125; 构建连接工厂(ConnectionFactory)1.构建ApiAdaptor123456789101112131415161718192021222324252627282930public class QQAdapter implements ApiAdapter&lt;QQ&gt; &#123;// 测试服务是否连接状态 @Override public boolean test(QQ qq) &#123; return true; &#125;// 常规数据项 @Override public void setConnectionValues(QQ qq, ConnectionValues connectionValues) &#123; QQUserInfo userInfo = qq.getQQUserInfo(); connectionValues.setDisplayName(userInfo.getNickname()); connectionValues.setImageUrl(userInfo.getFigureurl_qq_1()); connectionValues.setProfileUrl(null); //个人主页 connectionValues.setProviderUserId(userInfo.getOpenId()); &#125; // 获取用户信息 绑定解绑 @Override public UserProfile fetchUserProfile(QQ qq) &#123; return null; &#125; @Override public void updateStatus(QQ qq, String s) &#123;// &#125;&#125; 2.使用Adapter与serviceProvider构建connectionFactory1234567@ConditionalOnProperty(prefix = "com.xjc.security.social.qq",name = "appId") //只有配置了qq的AppID此配置才生效, QQ登录才生效public class QQConnectionFactory extends OAuth2ConnectionFactory&lt;QQ&gt; &#123; public QQConnectionFactory(String providerId, String appId,String appSecret) &#123; super(providerId, new QQServiceProvider(appId,appSecret), new QQAdapter()); &#125;&#125; 配置Social1.创建Social表对象第三方应用于本地应用用户关系对应表123456789101112131415CREATE TABLE `userconnection` ( `userId` varchar(255) NOT NULL, `providerId` varchar(255) NOT NULL, `providerUserId` varchar(255) NOT NULL, `rank` int(11) NOT NULL, `displayName` varchar(255) DEFAULT NULL, `profileUrl` varchar(512) DEFAULT NULL, `imageUrl` varchar(512) DEFAULT NULL, `accessToken` varchar(512) NOT NULL, `secret` varchar(512) DEFAULT NULL, `refreshToken` varchar(512) DEFAULT NULL, `expireTime` bigint(20) DEFAULT NULL, PRIMARY KEY (`userId`,`providerId`,`providerUserId`), UNIQUE KEY `UserConnectionRank` (`userId`,`providerId`,`rank`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2.SocialConfigure (继承SocialConfigurerAdapter&lt;适配器&gt;)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * @author: xjc * @date 2018/11/29 11:35 * @description QQ登录适配器 * * 配置此适配器后,第三方登录生效,拦截url请求为 /oauth/&lt;providerId&gt; * **/@Configuration@ConditionalOnProperty(prefix = "com.xjc.security.social.qq",name = "appId") //只有配置了qq的AppID此配置才生效, QQ登录才生效@Slf4jpublic class QQAutoConfigurerAdapter extends SocialConfigurerAdapter &#123; @Autowired private UserService userService; @Resource private SsoSecurityProperties ssoSecurityProperties; @Autowired private DataSource dataSource; /** * @author:xjc * @date:2018/12/2 * @description: spring-oauth2.0包之后必须重写该方法 返回主项目中对应userId, */ @Override public UserIdSource getUserIdSource() &#123; return userService; &#125; @Override public void addConnectionFactories(ConnectionFactoryConfigurer configurer, Environment environment) &#123; configurer.addConnectionFactory(createConnectionFactory()); &#125; protected ConnectionFactory&lt;?&gt; createConnectionFactory() &#123; QQProperties qqProperties=ssoSecurityProperties.getSocial().getQq(); return new QQConnectionFactory(qqProperties.getProviderId(), qqProperties.getAppId(), qqProperties.getAppSecret()); &#125; /** * @author:xjc * @date:2018/12/1 * @description: 这里注意:必须复写 getUsersConnectionRepository方法,jdbcRepository才生效 * 可能我没有设置配置文件优先级 * @params: */ @Override //SpringSocial 包含 public UsersConnectionRepository getUsersConnectionRepository(ConnectionFactoryLocator connectionFactoryLocator) &#123; JdbcUsersConnectionRepository repository = new JdbcUsersConnectionRepository(dataSource, connectionFactoryLocator, Encryptors.noOpText()); 操作 //repository.setTablePrefix(); //设置表前缀(可选) // repository.setConnectionSignUp(); // 注册操作 /*repository.setConnectionSignUp(new ConnectionSignUp() &#123; @Override public String execute(Connection&lt;?&gt; connection) &#123; return getUserIdSource().getUserId(); &#125; &#125;);*/ return repository; &#125; 3.在security配置启动中加入Social拦截器配置 问题 QQ显示错误的回调原因,回调地址为localhost:8080….. 与互联上配置的不一致.解决: 修改本地host文件,映射localhost与QQ互联上的回调域名一致 登录成功跳转/sinIn 路径原因:登录成功 spring-social会使用jdbcRepository(自己配置的)查询数据库中是否有对应的openId(在数据库中为providerUserId ),若没有.会默认跳往/sinIn 进行注册解决:在SocialConifg配置中自定义注册页面]]></content>
      <categories>
        <category>spring-security</category>
      </categories>
      <tags>
        <tag>socail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webupload+springboot实现文件上传]]></title>
    <url>%2F2018%2F11%2F21%2Fwebupload-springboot%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[使用webupload实现文件分片上传Web UploaderWebUploader是由Baidu WebFE(FEX)团队开发的一个简单的以HTML5为主，FLASH为辅的现代文件上传组件。在现代的浏览器里面能充分发挥HTML5的优势，同时又不摒弃主流IE浏览器，沿用原来的FLASH运行时，兼容IE6+，iOS 6+, android 4+。两套运行时，同样的调用方式，可供用户任意选用。采用大文件分片并发上传，极大的提高了文件上传效率。 创建upload项目并引入jar包及webupload组件 主要pom依赖 1234567891011121314151617181920212223242526272829303132 &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt; &lt;!--druid--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt;&lt;/dependency&gt;&lt;!--MySQL Driver--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt;&lt;/dependency&gt;&lt;!--junit--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring data jpa--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 引入webupload组件 创建实体对象 FileEntity 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.example.entity;import lombok.Getter;import lombok.Setter;import javax.persistence.*;import java.io.Serializable;import java.util.Date;/** * @author: xjc * @date 2018/11/20 15:12 * @description **/@Getter@Setter@Entity@Table(name="file")public class FileEntity implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @Column(name = "id") private String id; // 文件类型 type @Column(name="type") private String type; // 文件后缀 fix @Column(name="fix") private String fix; // 文件名 name @Column(name="name") private String name; // 创建者 creator @Column(name="user_id") private Long userId; // 文件大小 size @Column(name="size") private Long size; // 文件地址 path @Column(name="path") private String path; // 备注信息 remark @Column(name="remark") private String remark; // 其他 other @Column(name="other") private String other; private Date created; &#125; FileBlock 1234567891011121314151617181920212223242526272829303132333435363738 package com.example.entity;import lombok.Getter;import lombok.Setter;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.Table;import java.io.Serializable;import java.util.Date;/** * @author: xjc * @date 2018/11/20 17:29 * @description **/@Entity@Getter@Setter@Table(name = "fileBlock")public class FileBlock implements Serializable &#123; private static final long serialVersionUID = 1L; @Id private String id;// 块下标 private String chunk;// 块大小 private Long chunkSize;// 块标识 private String md5;// 块路径 private String path;// 块名称 private String name; private Date created;&#125; 创建页面html代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--引入CSS--&gt; &lt;link rel="stylesheet" type="text/css" href="/css/webuploader.css"&gt; &lt;!--引入JS--&gt; &lt;script type="text/javascript" src="/js/admin.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/jquery-1.8.3.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/webuploader.min.js"&gt;&lt;/script&gt; &lt;!--SWF在初始化的时候指定，在后面将展示--&gt; &lt;style&gt; #ctlBtn &#123; top: 0px; left: 0px; width: 94px; height: 40.8px; overflow: hidden; bottom: auto; right: auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="uploader" class="wu-example"&gt; &lt;!--用来存放文件信息--&gt; &lt;div id="thelist" class="uploader-list"&gt;&lt;/div&gt; &lt;div class="btns"&gt; &lt;div id="picker"&gt;选择文件&lt;/div&gt; &lt;button id="ctlBtn" class="btn btn-default"&gt;开始上传&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var md5; //监听分块上传过程中的三个时间点 WebUploader.Uploader.register(&#123; "before-send-file": "beforeSendFile", "before-send": "beforeSend", "after-send-file": "afterSendFile" &#125;, &#123; //时间点1：所有分块进行上传之前调用此函数 beforeSendFile: function (file) &#123; var deferred = WebUploader.Deferred(); //1、计算文件的唯一标记，用于断点续传 (new WebUploader.Uploader()).md5File(file, 0, 10 * 1024 * 1024) .progress(function (percentage) &#123; $('#' + file.id).find("p.state").text("正在读取文件信息..."); &#125;) .then(function (val) &#123; md5 = val; $('#' + file.id).find("p.state").text("成功获取文件信息..."); //获取文件信息后进入下一步 deferred.resolve(); &#125;); return deferred.promise(); &#125;, //时间点2：如果有分块上传，则每个分块上传之前调用此函数 beforeSend: function (block) &#123; var deferred = WebUploader.Deferred(); $.ajax(&#123; type: "get", url: BASE_PATH + "/file/check", data: &#123; //文件唯一标记 "md5": md5, //当前分块下标 "chunk": block.chunk, //当前分块大小 "chunkSize": block.end - block.start &#125;, //无缓存 cache: false, //无异步（必须加，否则异步上传会上传已经上传过的块） async: false, dataType: "json", success: function (data) &#123; if (data) &#123; //分块存在，跳过 deferred.reject(); &#125; else &#123; //分块不存在或不完整，重新发送该分块内容 deferred.resolve(); &#125; &#125; &#125;); this.owner.options.formData.md5 = md5; deferred.resolve(); return deferred.promise(); &#125;, // 时间点3：所有分块上传成功后调用此函数 afterSendFile: function () &#123; //如果分块上传成功，则通知后台合并分块 $.ajax(&#123; type: "POST", url: BASE_PATH + "/file/merge", data: &#123; md5: md5, &#125;, success: function (response) &#123; alert("上传成功"); &#125; &#125;); &#125; &#125;); var uploader = WebUploader.create(&#123; // swf文件路径 swf: BASE_PATH + "/js/Uploader.swf", // 文件接收服务端。 server: BASE_PATH + "/file/upload", // 选择文件的按钮。可选。 // 内部根据当前运行是创建，可能是input元素，也可能是flash. pick: "#picker", // 不压缩image, 默认如果是jpeg，文件上传前会压缩一把再上传！ resize: false, //开启分片上传 chunked: true, //分片大小 chunkSize: 10* 1024 * 1024, //*10 //并发数 threads: 3 //请求参数表 // formData:datalist, &#125;); $("#ctlBtn").on("click", function () &#123; uploader.upload(); &#125;); // 当有文件被添加进队列的时候 uploader.on('fileQueued', function (file) &#123; $("#thelist").append("&lt;div id=\"" + file.id + "\" class=\"item\"&gt;" + "&lt;h4 class=\"info\"&gt;" + file.name + "&lt;/h4&gt;" + "&lt;p class=\"state\"&gt;等待上传...&lt;/p&gt;" + "&lt;/div&gt;"); //暂停上传的文件 $("#thelist").on('click', '.stop', function () &#123; uploader.stop(true); &#125;), //删除上传的文件 $("#thelist").on('click', '.remove', function () &#123; if ($(this).parents(".item").attr('id') === file.id) &#123; uploader.removeFile(file); $(this).parents(".item").remove(); &#125; &#125;) &#125;); // 文件上传过程中创建进度条实时显示。 uploader.on('uploadProgress', function (file, percentage) &#123; var $li = $('#' + file.id); var $percent = $li.find('.progress .progress-bar'); // 避免重复创建 if (!$percent.length) &#123; // $percent = $('&lt;div class="progress progress-striped active"&gt;' + // '&lt;div class="progress-bar" role="progressbar" style="width: 0%"&gt;' + // '&lt;/div&gt;' + // '&lt;/div&gt;').appendTo($li).find('.progress-bar'); $percent = $('&lt;div class="progress progress-striped active"&gt;' + '&lt;div class="progress-bar" role="progressbar" style="width: 0%"&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;').appendTo($li).find('.progress'); &#125; $li.find('p.state').text('上传中'); $percent.css(&#123;'width': percentage * 100 + '%', 'height': 10, 'background-color': 'blue'&#125;); &#125;); uploader.on('uploadSuccess', function (file) &#123; $('#' + file.id).find('p.state').text('已上传'); &#125;); uploader.on('uploadError', function (file) &#123; $('#' + file.id).find('p.state').text('上传出错'); &#125;); uploader.on('uploadComplete', function (file) &#123; $('#' + file.id).find('.progress').fadeOut(); &#125;);&lt;/script&gt;&lt;/html&gt; 页面展示:选择文件并上传,webupload会将文件分成片段通过多线程向服务器发送请求主要分为三个请求:upload(上传片段),check(检验片段是否存在),merge(全部上传成功后合并片段) 在服务器端完成文件分片上传操作 创建FileEntityController接受页面请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182package com.example.controller; import com.example.common.FileUtils; import com.example.entity.FileBlock; import com.example.entity.FileEntity; import com.example.serivce.FileBlockService; import com.example.serivce.FileEntityService; import com.example.utils.Response; import org.n3r.idworker.Sid; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.*; import org.springframework.web.multipart.MultipartFile; import java.util.Date; import java.util.List; /** * @author: xjc * @date 2018/11/20 15:49 * @description **/ @RestController @RequestMapping("/file/") public class FileEntityController &#123; @Autowired protected FileEntityService service; @Autowired protected FileBlockService fileBlockService; @Value("$&#123;tempPath&#125;") protected String tempPath; @Value("$&#123;basePath&#125;") protected String basePath; @GetMapping( "/get/&#123;md5&#125;") public Response file(@PathVariable String md5)&#123; Response result = service.findById(md5); return result; &#125; /** * @author:xjc * @date:2018/11/20 * @description:文件分片上传 * @params:文件,整个文件的md5,片号,文件名,分片总数 */ @PostMapping("upload") public Response upload(@RequestParam(value = "file") MultipartFile file, @RequestParam(value = "md5") String md5, @RequestParam(value = "chunk", defaultValue = "0", required = false) String chunk, @RequestParam(value = "name") String name, @RequestParam(value = "chunks", defaultValue = "0", required = false) String chunks, @RequestParam(value = "type") String type )&#123; String uploadPath = tempPath + "\\###" + chunk + "###" + name; // 判断大文件是否存在 if(service.findById(md5).getStatus()!=200)&#123; // 由于webUpload多线程上传,所以要加锁 synchronized (FileEntityService.class) &#123; if (service.findById(md5).getStatus() != 200) &#123; // 保存FileEntity到数据库中 FileEntity fileEntity = new FileEntity(); fileEntity.setId(md5); fileEntity.setCreated(new Date()); fileEntity.setType(type); fileEntity.setFix(name.substring(name.lastIndexOf(".") + 1)); fileEntity.setName(name); fileEntity.setSize(file.getSize()); // fileEntity.setPath(); // fileEntity.setUserId(); // 保存文件到数据库中 service.save(fileEntity); &#125; &#125; &#125; /* * webUpload请求判断重复 * */ // 判断文件片段是否存在 // FileBlock fileBlock = fileBlockService.findByMd5AndChunk(md5, chunk); // if(fileBlock!=null)&#123; //// 判断文件大小是否一样 // // //// 由于数据库记录存上了,.所以不需要判断是否完成上传,直接返回上传成功 // // // &#125; // if(fileBlock!=null) // return Response.ok(); // 开始上传文件片段 service.upload(file, chunk, name, uploadPath); // 上传成功保存到数据库中 FileBlock fileBlock = new FileBlock(); fileBlock.setId(Sid.next()); fileBlock.setMd5(md5); fileBlock.setChunk(chunk); fileBlock.setChunkSize(file.getSize()); fileBlock.setPath(uploadPath); fileBlock.setName("###" + chunk + "###" + name); fileBlock.setCreated(new Date()); fileBlockService.save(fileBlock); return Response.ok(); &#125; /** * @author:xjc * @date:2018/11/20 * @description:检查片段是否已经上传 * @params: */ @GetMapping("check") public boolean check(@RequestParam(value = "md5") String md5, @RequestParam(value = "chunk") String chunk )&#123; FileBlock fileBlock = fileBlockService.findByMd5AndChunk(md5, chunk); if(fileBlock==null) synchronized (FileBlock.class) &#123; if(fileBlockService.findByMd5AndChunk(md5, chunk)==null) return false; &#125; return true; &#125; /** * @author:xjc * @date:2018/11/20 * @description:合并片段 * @params: */ @PostMapping("merge") public Response merge(@RequestParam(value = "md5") String md5)&#123; // 查询所有md5片段集合(该集合是无顺序的),转换顺序 List&lt;FileBlock&gt; list = fileBlockService.findByMd5(md5); String[] paths=new String[list.size()]; for(int i=0;i&lt;list.size();i++)&#123; FileBlock fileBlock=list.get(i); String path = fileBlock.getPath(); Integer chunk = Integer.parseInt(fileBlock.getChunk()); paths[chunk]=path; &#125; // final String[] path, final String finalSavePath if(list.size()==0) return Response.error(); FileBlock fileBlock=list.get(0); String path = fileBlock.getPath(); String[] split = path.split("###"); String name=split[2]; String savePath=basePath+"\\"+name; try &#123; FileUtils.mergeFile(paths,savePath); &#125; catch (Exception e) &#123; e.printStackTrace(); return Response.error(); &#125; return Response.ok(); &#125; &#125; FileEntityService与FileBlockService 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.example.serivce;import com.example.common.FileUtils;import com.example.entity.FileBlock;import com.example.entity.FileEntity;import com.example.repository.FileEntityRepository;import com.example.utils.Response;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.web.multipart.MultipartFile;/** * @author: xjc * @date 2018/11/20 15:33 * @description **/@Servicepublic class FileEntityService &#123; @Autowired FileEntityRepository fileEntityRepository; public Response findById(String md5)&#123; if(md5==null||"".equals(md5)) return Response.error("null"); FileEntity fileEntity = null; try &#123;// 没找到会报错 fileEntity = fileEntityRepository.findById(md5).get(); return Response.ok("OK",fileEntity); &#125; catch (Exception e) &#123; System.out.println(FileEntityService.class+"找不到ID:::"+md5); return Response.error("null"); &#125; &#125; public void upload(MultipartFile file, String chunk, String name,String uploadPath) &#123; try &#123;// 上传片段 FileUtils.uploaded(file,uploadPath);// 成功存储数据到数据库 FileBlock fileBlock = new FileBlock(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void save(FileEntity fileEntity)&#123; fileEntityRepository.save(fileEntity); &#125;&#125; package com.example.serivce;import com.example.entity.FileBlock;import com.example.repository.FileBlockRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * @author: xjc * @date 2018/11/20 20:40 * @description **/@Servicepublic class FileBlockService &#123; @Autowired protected FileBlockRepository repository; public void save(FileBlock fileBlock)&#123; repository.save(fileBlock); &#125; public List&lt;FileBlock&gt; findByMd5(String md5)&#123; return repository.findByMd5(md5); &#125; public FileBlock findByMd5AndChunk(String md5,String chunk)&#123; return repository.findByMd5AndChunk(md5,chunk); &#125;&#125; FileUtils(文件读写与合并) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.example.common;import org.springframework.web.multipart.MultipartFile;import java.io.*;import java.nio.channels.FileChannel;import java.nio.channels.WritableByteChannel;/** * @author: xjc * @date 2018/11/20 19:01 * @description **/public class FileUtils &#123; public static void uploaded( MultipartFile file,// final String md5,// final String guid,// final String chunk, final String uploadFolderPath// final String fileName,// final String ext,// final String filePath) )throws Exception &#123; File uploadFile = new File(uploadFolderPath); if(uploadFile.exists())&#123; uploadFile.delete(); &#125; byte[] data = readInputStream(file.getInputStream()); try (FileOutputStream outStream = new FileOutputStream(uploadFile)) &#123;//写入数据 outStream.write(data); outStream.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw e; &#125; &#125; public static byte[] readInputStream(InputStream inStream) throws Exception &#123; ByteArrayOutputStream outStream = new ByteArrayOutputStream(); //创建一个Buffer字符串 byte[] buffer = new byte[1024]; //每次读取的字符串长度，如果为-1，代表全部读取完毕 int len; //使用一个输入流从buffer里把数据读取出来 while ((len = inStream.read(buffer)) != -1) &#123; //用输出流往buffer里写入数据，中间参数代表从哪个位置开始读，len代表读取的长度 outStream.write(buffer, 0, len); &#125; //关闭输入流 inStream.close(); //把outStream里的数据写入内存 return outStream.toByteArray(); &#125; /** * @author:xjc * @date:2018/11/20 * @description:合并文件 * @params: */ public static void mergeFile(final String[] paths, final String finalSavePath) throws Exception &#123; if(paths.length==1)&#123;// 不需要合并 InputStream is= new FileInputStream(paths[0]); saveStreamToFile(is,finalSavePath); return ; &#125;// SequenceInputStream s ;//// InputStream s1 = new FileInputStream(list.get(0).getPath());//// InputStream s2 = new FileInputStream(list.get(1).getPath());//// s = new SequenceInputStream(s1, s2);//// for (int i=2;i&lt;list.size();i++) &#123;//// InputStream s3 = new FileInputStream(list.get(i).getPath());//// s = new SequenceInputStream(s, s3);//// &#125;//////// //通过输出流向文件写入数据//// saveStreamToFile(s, finalSavePath); FileOutputStream output = new FileOutputStream(new File(finalSavePath)); WritableByteChannel targetChannel = output.getChannel(); for(int i =0; i&lt;paths.length; i++)&#123; FileInputStream input = new FileInputStream(paths[i]); FileChannel inputChannel = input.getChannel(); inputChannel.transferTo(0, inputChannel.size(), targetChannel); inputChannel.close(); input.close(); &#125; targetChannel.close(); output.close(); &#125; /** * 从stream中保存文件 * * @param inputStream inputStream * @param filePath 保存路径 * @throws Exception 异常 抛异常代表失败了 */ public static void saveStreamToFile( final InputStream inputStream, final String filePath) throws Exception &#123; /*创建输出流，写入数据，合并分块*/ OutputStream outputStream = new FileOutputStream(filePath); byte[] buffer = new byte[1024]; int len = 0; try &#123; while ((len = inputStream.read(buffer)) != -1) &#123; outputStream.write(buffer, 0, len); outputStream.flush(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); throw e; &#125; finally &#123; outputStream.close(); inputStream.close(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>commons</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试笔记]]></title>
    <url>%2F2018%2F11%2F16%2F%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[springboot 中配置文件注入实体类.使用两个注解: @Configuriation 将实体类注入到spring容器中,相当于在xml中配置标签 @ConfigruiationProperties(prefix = “***”) 相当于读取application.yml文件中的配置属性 在application.yml文件中定义 实体类属性实例:在yml文件中配置实体类属性 1234***: ***: ***: ***: 扩展在springboot中使用多个yml配置文件.(基本环境,开发环境(dev),上线环境(prod)) application.yml (基本环境) 12345678910111213141516spring: profiles: active: @spring.profiles.active@ ##通过此项指定默认配置,在pom文件中配置 mvc: throw-exception-if-no-handler-found: true http: multipart: max-file-size: 10MB aop: proxy-target-class: true cache: type: caffeineserver: error: whitelabel: enabled: false applicaiton-dev.yml (开发环境) 1包括数据库,缓存大小等开发环境与上线环境不同的配置信息 applicaiton-prod.yml(上线环境) 配置pom.xml,修改默认配置文件信息 12345678910111213141516171819&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;activation&gt; &lt;!--默认激活--&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;!--主要通过此项修改默认配置 --&gt; &lt;spring.profiles.active&gt;dev&lt;/spring.profiles.active&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;spring.profiles.active&gt;prod&lt;/spring.profiles.active&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; 部署的工程目录结构. -传统war包项目 123456789--WEB-INF --静态文件 --classes --编译代码 --配置文件 --lib --依赖jar包--META-INF --软件版本号 -springboot 项目 123456--静态文件--配置文件--编译代码--META-INF --MAVEN-pom文件 --软件版本号 springboot2.0新特性]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot自动注入出现define报错]]></title>
    <url>%2F2018%2F10%2F27%2Fspringboot%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E5%87%BA%E7%8E%B0define%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[SpringBoot@Autowired无法注入搭建完spring boot的demo后自然要实现自动注入来体现spring ioc的便利了，但是我在实施过程中出现了这么一个问题，见下面，这里找到解决办法记录下来，供遇到同样的问题的同僚参考 123456789Field baseRedisService in com.itmayiedu.common.base.BaseApiService required a bean of type 'com.itmayiedu.common.base.BaseRedisService' that could not be found.Action:Consider defining a bean of type 'com.itmayiedu.common.base.BaseRedisService' in your configuration.Process finished with exit code 1 百度答案参考根据英文的提示是在配置中找不到一个指定自动注入类型的bean，经过多方排查得出结论： 正常情况下加上@Component注解的类会自动被Spring扫描到生成Bean注册到spring容器中，既然他说没找到，也就是该注解被没有被spring识别，问题的核心关键就在application类的注解SpringBootApplication上 这个注解其实相当于下面这一堆注解的效果，其中一个注解就是@Component，在默认情况下只能扫描与控制器在同一个包下以及其子包下的@Component注解，以及能将指定注解的类自动注册为Bean的@Service@Controller和@ Repository，至此明白问题所在，之前我将接口与对应实现类放在了与控制器所在包的同一级目录下，这样的注解自然是无法被识别的 解决至此，得出两种解决办法： 1 .将接口与对应的实现类放在与application启动类的同一个目录或者他的子目录下，这样注解可以被扫描到，这是最省事的办法 2 .在指定的application类上加上这么一行注解，手动指定application类要扫描哪些包下的注解]]></content>
      <categories>
        <category>报错</category>
      </categories>
      <tags>
        <tag>springboot报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket与Netty]]></title>
    <url>%2F2018%2F10%2F27%2FWebSocket%E4%B8%8ENetty%2F</url>
    <content type="text"><![CDATA[WebSocket介绍WebSocket是一个协议，归属于IETF。 HTTP是运行在TCP协议传输层上的应用协议，而WebSocket是通过HTTP协议协商如何连接，然后独立运行在TCP协议传输层上的应用协议。 Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。 websocket约定了一个通信的规范，通过一个握手的机制，客户端和服务器之间能建立一个类似tcp的连接，从而方便它们之间的通信 什么是Netty 高性能事件驱动 异步非阻塞 基于NIO的客户端,服务端编程框架 提供异步的、事件驱动的网络应用程序框架和工具 简单来说: 你想写个tomcat一样的Server，可以用netty。 你想写一个即时通讯的应用，可以用netty。 你想实现一个高性能Rpc框架，可以用netty。 netty的IO模型Netty的I/O模型基于非阻塞I/O实现，底层依赖的是JDK NIO框架的Selector。 Netty应用范围 高性能领域(游戏,大数据,分布式) 多线程并发领域 异步通信领域 优点概述WebSocket最大的特点就是长连接，能够实时推送数据。 使用Netty搭建客户端与服务端实时通讯,网络群发netty入门之webSocket初体验 创建工程全局配置类. 123456789/** * @Author:xjc * @Date:2018/10/26 * @Description: 存储整个工程的全局配置 */public class NettyConfig &#123;// 全局管道组对象 public static ChannelGroup group=new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);&#125; 初始化WebSocket组件(这里API没理解) 1234567891011121314151617181920/** * @author: xjc * @date 2018/10/26 22:22 * @description 初始化链接时的各个组件 **/public class MyWebSocketChannelHandler extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel e) throws Exception &#123;// ------ e.pipeline().addLast("http-codec",new HttpServerCodec());// ----- e.pipeline().addLast("aggregator",new HttpObjectAggregator(65536));// ------ e.pipeline().addLast("http-chunked",new ChunkedWriteHandler());// ----- e.pipeline().addLast("handler",new MySocketHandler()); &#125;&#125; 创建MySocketHandler处理器(实现四个方法) 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @author: xjc * @date 2018/10/26 21:36 * @description: 接收处理响应websokect请求业务核心逻辑 **/public class MySocketHandler extends SimpleChannelInboundHandler&lt;Object&gt; &#123; // 核心方法. protected void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception &#123; &#125; // 客户端与服务端创立连接时调用 @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; // ----- NettyConfig.group.add(ctx.channel()); System.out.println("客户端与服务端连接开启"); &#125; // 客户端与服务端断开连接时调用 @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; NettyConfig.group.remove(ctx.channel()); System.out.println("客户端与服务端连接关闭"); &#125; // 服务端接收客户端发送过来的数据结束之后调用 @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; ctx.flush(); // ------ &#125; // 工程出现异常时调用 @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); //关闭连接 &#125;&#125; 定义全局变量(握手对象与socketURL) 12345// --- private WebSocketServerHandshaker handshake; // 定义全局变量默认访问路径 private static final String WEB_SOCKET_URL="ws://localhost:8080/websocket"; 核心方法(messageReceived) 123456789101112 // 核心方法.protected void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception &#123; // 表示客户端向服务端发起握手请求; if(msg instanceof FullHttpRequest) &#123; handHttpRequest(ctx,(FullHttpRequest)msg); &#125;else if(msg instanceof WebSocketFrame) &#123; // 处理websocket连接业务 handWebSocketFrame(ctx, (WebSocketFrame) msg); &#125;&#125; 实现handHttpRequest()与handWebSocketFrame()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * @Author:xjc * @Date:2018/10/26 * @Description:处理客户端与服务端之间的websocket业务 */ private void handWebSocketFrame(ChannelHandlerContext ctx,WebSocketFrame frame)&#123; // 判断是否为关闭webSocket指令 if(frame instanceof CloseWebSocketFrame)&#123; handshake.close(ctx.channel(), (CloseWebSocketFrame) frame.retain()); &#125; // 判断是否是ping消息 if(frame instanceof PingWebSocketFrame)&#123; ctx.channel().write(new PongWebSocketFrame(frame.content().retain())); return ; &#125; // 判断是否是二进制消息,如果是二进制消息,抛出异常 if(!(frame instanceof TextWebSocketFrame))&#123; System.out.println("目前不支持二进制消息"); throw new RuntimeException(this.getClass().getName()+"不支持消息"); &#125; // 返回应答消息 String request=((TextWebSocketFrame)frame).text(); System.out.println("服务端收到客户端消息======&gt;&gt;&gt;&gt;"+request); TextWebSocketFrame tws=new TextWebSocketFrame(new Date().toString()+ctx.channel().id()+"======&gt;&gt;&gt;"+request); // 群发:服务端向每个链接上的客户端群发消息 NettyConfig.group.writeAndFlush(tws); &#125; /** * @Author:xjc * @Date:2018/10/26 * @Description: 处理客户端向服务端发起Http请求的业务 */ private void handHttpRequest(ChannelHandlerContext ctx,FullHttpRequest req)&#123; if(!req.getDecoderResult().isSuccess()||!"websocket".equals(req.headers().get("Upgrade")))&#123; // 不是客户端向客户端发送的Http请求 sendHttpRsponse(ctx,req,new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.BAD_REQUEST)); return ; &#125; WebSocketServerHandshakerFactory wsFactory=new WebSocketServerHandshakerFactory(WEB_SOCKET_URL,null,false); handshake =wsFactory.newHandshaker(req); if(handshake==null)&#123; WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel()); &#125;else&#123; handshake.handshake(ctx.channel(),req); &#125; &#125; 实现sendHttpRsponse()服务端向客户端发送请求 12345678910111213141516171819 /** * @Author:xjc * @Date:2018/10/26 * @Description:服务端向客户端发送数据 */ private void sendHttpRsponse(ChannelHandlerContext ctx, FullHttpRequest req, DefaultFullHttpResponse res)&#123; if(res.getStatus().code()!=200)&#123; ByteBuf buf= Unpooled.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8); res.content().writeBytes(buf); buf.release(); &#125;// 服务端向客户端发送数据 ChannelFuture f=ctx.channel().writeAndFlush(res); if(res.getStatus().code()!=200)&#123; f.addListener(ChannelFutureListener.CLOSE); &#125; &#125; 实现客户端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;html&gt; &lt;head&gt; &lt;mate http-equiv="Content-type" content="text/html;charset=utf-8"/&gt; &lt;title&gt;WebSocket客户端&lt;/title&gt; &lt;script type="text/javascript"&gt; var socket; if(!window.WebSocket)&#123; window.WebSocket= window.MozWebSocket; &#125; if(window.WebSocket)&#123; socket=new WebSocket("ws://localhost:8080/websocket"); socket.onmessage= function(event)&#123; var ta = document.getElementById("responseContent"); ta.value +=event.data + "\r\n"; &#125;; socket.onopen= function(event)&#123; var ta = document.getElementById("responseContent"); ta.value = "您当前的浏览器支持webSocket,请进行后续操作 \r\n"; &#125; socket.onclose=function(event)&#123; var ta = document.getElementById("responseContent"); ta.value=""; ta.value="WebSocket连接已经关闭 \n"; &#125; &#125;else&#123; alert("您的浏览器不支持websocket"); &#125; function send(message)&#123; if(!window.WebSocket)&#123; return ; &#125; if(socket.readyState == WebSocket.OPEN)&#123; socket.send(message); &#125;else&#123; alert("socket连接没有成功"); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form onSubmit="return false;"&gt; &lt;input type="text" name = "message" value = "" /&gt; &lt;br/&gt;&lt;br/&gt; &lt;input type="button" value = "发送WebSocekt请求消息" onClick = "send(this.form.message.value)" /&gt; &lt;hr color="red" /&gt; &lt;h2&gt;客户端接收到服务端返回的应答消息&lt;/h2&gt; &lt;textarea id="responseContent" style="width:1024px;height:300px;" &gt;&lt;/textarea&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 启动服务器 1234567891011121314151617181920212223242526/** * @author: xjc * @date 2018/10/26 22:28 * @description 程序的入口,负责启动应用 **/public class Main &#123; public static void main(String[] args) &#123;// ---- EventLoopGroup bossGroup=new NioEventLoopGroup();// ---- EventLoopGroup workGroup=new NioEventLoopGroup();// --- try &#123; ServerBootstrap b=new ServerBootstrap(); b.group(bossGroup,workGroup); b.channel(NioServerSocketChannel.class); b.childHandler(new MyWebSocketChannelHandler()); System.out.println("服务端开启等待客户端连接"); Channel ch = b.bind(8080).channel(); ch.closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 测试 开启两个网页,实现群聊]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bookNotes-1]]></title>
    <url>%2F2018%2F10%2F23%2FbookNotes-1%2F</url>
    <content type="text"><![CDATA[消除过期对象的引用 在C语言与C++中,创建对象使用完毕后一般会回收对象,但在JAVA中,由于Java回收机制的存在,对象会自动回收. 但在某些条件下java无法回收过期对象而导致内存泄漏. 例:1234567891011121314151617181920212223242526272829303132public class Stack &#123; private Object[] elements; private Integer size=0; private static final Integer DEFULT_CAPACITY=16; public Stack()&#123; this.elements=new Object[DEFULT_CAPACITY]; &#125; public void push(Object object)&#123; ensureCapacity(); this.elements[size++]=object; &#125; public Object pop()&#123; if(size==0) throw new IndexOutOfBoundsException(); return this.elements[--size]; &#125; /** * @Author:xjc * @Date:2018/10/22 * @Description: 确保容量 */ private void ensureCapacity()&#123; if(elements.length==size) this.elements= Arrays.copyOf(elements,size&lt;&lt;1); &#125;&#125; 上面例子是一个队列,并没有明显错误.但其中隐藏了一个’内存泄漏’问题. 比如程序中push了很多对象后,又调用pop方法弹出栈.缺没有后续的push方法替换已经pop出去了的对象的引用.导致java虚拟机无法回收. 即时只有少量几个对象的引用被无意识的保留下来,也会有许许多多的对象被排除在垃圾回收机制之外,从而潜在对性能造成重大影响 修复:一旦对象引用过期,就清空这些引用1234567public Object pop()&#123; if(size==0) throw new IndexOutOfBoundsException(); Object obj = this.elements[--size]; this.elements[size]=null; return obj; &#125; 总结一般而言,只要类是自己管理内存(像Stack中object数据,其中的废弃与有用由自己决定),就应该警惕内存泄漏]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql主备复制与读写分离]]></title>
    <url>%2F2018%2F10%2F21%2Fmysql%E4%B8%BB%E5%A4%87%E8%B5%8B%E5%80%BC%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[实现两台mysql服务器主从复制服务器配置 准备两台服务器. 修改主服务器 (master) my.cnf配置文件,设置服务器唯一ip 主服务器开放账号运行下面sql语句 修改从服务器(slave) 配置文件 开启主备机同步 查询master服务器状态.show master status; 在从服务器中链接主服务器 (注意服务器IP以及日志点位与主服务器对应) 查看slave服务器状态(都为YES是,表示搭建成功). 使用myCat实现数据库读写分离 使用myCat 中间件,在server.xml中添加两个用户,分别用来读与写; 123456789&lt;user name="mycat"&gt; &lt;property name="password"&gt;mycat&lt;/property&gt; &lt;property name="schemas"&gt;mycat&lt;/property&gt; &lt;/user&gt; &lt;!-- 添加user --&gt; &lt;user name="mycat_red"&gt; &lt;property name="password"&gt;mycat_red&lt;/property&gt; &lt;property name="schemas"&gt;mycat&lt;/property&gt; &lt;property name="readOnly"&gt;true&lt;/property&gt; 修改scheme.xml 相关配置; 123456789101112131415161718&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt;&lt;mycat:schema xmlns:mycat="http://org.opencloudb/"&gt; &lt;!-- 与server.xml中user的schemas名一致 --&gt; &lt;schema name="mycat" checkSQLschema="true" sqlMaxLimit="100"&gt; &lt;table name="t_users" primaryKey="user_id" dataNode="dn1" rule="rule1"/&gt; &lt;table name="t_message" type="global" primaryKey="messages_id" dataNode="dn1" /&gt; &lt;/schema&gt;&lt;dataNode name="dn1" dataHost="jdbchost" database="weibo_simple" /&gt; &lt;!--数据库名称 --&gt; &lt;dataHost name="jdbchost" maxCon="1000" minCon="10" balance="1" writeType="0" dbType="mysql" dbDriver="native" switchType="1" slaveThreshold="100"&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;writeHost host="hostMaster" url="192.168.25.134:3306" user="root" password="root"&gt; &lt;/writeHost&gt; &lt;writeHost host="hostSlave" url="192.168.25.135:3306" user="root" password="root"/&gt; &lt;/dataHost&gt;&lt;/mycat:schema&gt; 修改rule.xml 相关配置 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- - - Licensed under the Apache License, Version 2.0 (the "License"); - you may not use this file except in compliance with the License. - You may obtain a copy of the License at - - http://www.apache.org/licenses/LICENSE-2.0 - - Unless required by applicable law or agreed to in writing, software - distributed under the License is distributed on an "AS IS" BASIS, - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. - See the License for the specific language governing permissions and - limitations under the License. --&gt;&lt;!DOCTYPE mycat:rule SYSTEM "rule.dtd"&gt;&lt;mycat:rule xmlns:mycat="http://org.opencloudb/"&gt; &lt;tableRule name="rule1"&gt; &lt;rule&gt; &lt;columns&gt;user_id&lt;/columns&gt; &lt;algorithm&gt;func1&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt; &lt;function name="func1" class="org.opencloudb.route.function.AutoPartitionByLong"&gt; &lt;property name="mapFile"&gt;autopartition-long.txt&lt;/property&gt; &lt;/function&gt;&lt;/mycat:rule&gt; 启动myCat服务器,查看日志文件 使用读权限账号与读写权限账号分别连接myCat,实现读写分离操作.]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL调优]]></title>
    <url>%2F2018%2F10%2F18%2FMySQL%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[MySql如何优化 表的设计合理化(符合3NF) 定位慢查询,添加适当索引(index) [四种: 普通索引、主键索引、唯一索引unique、全文索引] SQL语句优化 分表技术(水平分割、垂直分割) 读写[写: update/delete/add]分离 使用存储过程 [模块化编程，可以提高速度] 数据库设计数据库三大范式第一范式：1NF是对属性的原子性约束，要求属性(列)具有原子性，不可再分解；(只要是关系型数据库都满足1NF)第二范式：2NF是对记录的惟一性约束，表中的记录是唯一的, 就满足2NF, 通常我们设计一个主键来实现，主键不能包含业务逻辑。第三范式：3NF是对字段冗余性的约束，它要求字段没有冗余。 没有冗余的数据库设计可以做到。 但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。 SQL优化定位慢查询使用show status使用show status查看MySQL服务器状态信息 常用命令 mysql数据库启动了多少时间 show status like ‘uptime’; 显示数据库的查询，更新，添加，删除的次数 show stauts like ‘com_select’ show stauts like ‘com_insert’… 显示到mysql数据库的连接数 show status like ‘connections ‘; 显示慢查询次数 show status like ‘slow_queries’; 查询慢查询时间 show variables like ‘long_query_time’; 修改慢查询时间 set long_query_time=1; —但是重启mysql之后，long_query_time依然是my.ini中的值 使用索引索引概述 索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都以B-树的形式保存。如果没有索引，执行查询时MySQL必须从第一个记录开始扫描整个表的所有记录，直至找到符合要求的记录。表里面的记录数量越多，这个操作的代价就越高。如果作为搜索条件的列上已经创建了索引，MySQL无需扫描任何记录即可迅速得到目标记录所在的位置。如果表有1000个记录，通过索引查找记录至少要比顺序扫描记录快100倍。 索引分类1、普通索引：create index on Tablename(列的列表) alter table TableName add index (列的列表) create table TableName([…], index [IndexName] (列的列表) 2、唯一性索引：create unique index alter … add unique 主键：一种唯一性索引，必须指定为primary key 3、全文索引：从3.23.23版开始支持全文索引和全文检索，FULLTEXT， 可以在char、varchar或text类型的列上创建。 4、单列索引、多列索引： 多个单列索引与单个多列索引的查询效果不同，因为： 执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。 5、最左前缀(Leftmost Prefixing)：多列索引，例如：fname_lname_age索引，以下的搜索条件MySQL都将使用 fname_lname_age索引：firstname,lastname,age；firstname,lastname；firstname，其他情况将不使用。 explain执行计划解读当我们在查询前能否预先估计查询究竟要涉及多少行、使用哪些索引、运行时间呢？答案是能的，mysql提供了相应的功能和语法来实现该功能。分析：MySql提供了EXPLAIN语法用来进行查询分析，在SQL语句前加一个”EXPLAIN”即可。比如我们要分析如下SQL语句：explain select * from table where table.id = 1 运行上面的sql语句后你会看到，下面的表头信息： table | type | possible_keys | key | key_len | ref | rows | Extra 哪些列上适合添加索引① 肯定在where条件经常使用② 该字段的内容不是唯一的几个值③ 字段内容不是频繁变化]]></content>
      <categories>
        <category>java高级</category>
      </categories>
      <tags>
        <tag>MySQL调优</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot热部署]]></title>
    <url>%2F2018%2F09%2F27%2FSpringboot%2F</url>
    <content type="text"><![CDATA[使用devtools进行热部署1.引入devtools依赖12345678910111213141516&lt;!-- 热部署 --&gt;&lt;!-- devtools可以实现页面热部署（即页面修改后会立即生效，这个可以直接在application.properties文件中配置spring.thymeleaf.cache=false来实现） --&gt;&lt;!-- 实现类文件热部署（类文件修改后不会立即生效），实现对属性文件的热部署。 --&gt;&lt;!-- 即devtools会监听classpath下的文件变动，并且会立即重启应用（发生在保存时机），注意：因为其采用的虚拟机机制，该项重启是很快的 --&gt;&lt;!-- （1）base classloader （Base类加载器）：加载不改变的Class，例如：第三方提供的jar包。 --&gt;&lt;!-- （2）restart classloader（Restart类加载器）：加载正在开发的Class。 --&gt;&lt;!-- 为什么重启很快，因为重启的时候只是加载了在开发的Class，没有重新加载第三方的jar包。 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;!-- optional=true, 依赖不会传递, 该项目依赖devtools; 之后依赖boot项目的项目如果想要使用devtools, 需要重新引入 --&gt;&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 2.热部署相关配置12345678#关闭缓存, 即时刷新#spring.freemarker.cache=falsespring.thymeleaf.cache=true#热部署生效spring.devtools.restart.enabled=true#设置重启的目录,添加那个目录的文件需要restartspring.devtools.restart.additional-paths=src/main/java IDEA中热部署无效解决方案 1.Alt+Ctrl+S 在Settting中配置如下:: 2.Shift+Ctrl+Alt+/，选择Registry]]></content>
      <categories>
        <category>spring-boot</category>
      </categories>
      <tags>
        <tag>热部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Mybatis]]></title>
    <url>%2F2018%2F09%2F27%2FSpringBoot%E6%95%B4%E5%90%88Mybatis%2F</url>
    <content type="text"><![CDATA[Springboot整合Mybatis1.添加依赖jar包1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--mapper tk插件 --&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt;&lt;/dependency&gt;&lt;!--pagehelper--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 2.配置文件:123456789101112131415161718192021222324252627282930313233############################################################## 配置数据源相关 使用阿里巴巴的 druid 数据源#############################################################spring.datasource.url=jdbc:mysql://localhost:3306/springbootspring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.druid.initial-size=1spring.datasource.druid.min-idle=1spring.datasource.druid.max-active=20spring.datasource.druid.test-on-borrow=truespring.datasource.druid.stat-view-servlet.allow=true############################################################## mybatis 配置############################################################## mybatis 配置mybatis.type-aliases-package=com.example.demo.entitymybatis.mapper-locations=classpath:mapper/*.xml# 通用 Mapper 配置mapper.mappers=com.example.demo.utils.MyMappermapper.not-empty=falsemapper.identity=MYSQL# 分页插件配置pagehelper.helperDialect=mysqlpagehelper.reasonable=truepagehelper.supportMethodsArguments=truepagehelper.params=count=countSql SpringBoot整合Mybatis逆向工程使用mapper插件 git地址 1.引入jar包:12345&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt;&lt;/dependency&gt; 2.引入mybatis逆向工程文件 3.运行生成:运行后会生成三个主要文件. MyMapper 插件接口; SysUserMapper 与 SysUserMapper.xml都是表映射 表中映射的mapper会自动继承MaMapper 使用:在service中注入调用即可.]]></content>
      <categories>
        <category>web框架</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中Volatile关键字解析]]></title>
    <url>%2F2018%2F09%2F26%2FJava%E4%B8%ADVolatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一、基本概念先补充一下概念：Java 内存模型中的可见性、原子性和有序性。 可见性： 可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。 可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。 在 Java 中 volatile、synchronized 和 final 实现可见性。 原子性： 原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。 在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。 有序性： Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。 下面内容摘录自《Java Concurrency in Practice》： 下面一段代码在多线程环境下，将存在问题。 123456789101112131415161718 public class NoVisibility &#123; private static boolean ready; private static int number; private static class ReaderThread extends Thread &#123; @Override public void run() &#123; while(!ready) &#123; Thread.yield(); &#125; System.out.println(number); &#125; &#125; public static void main(String[] args) &#123; new ReaderThread().start(); number = 42; ready = true; &#125;&#125; NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready的值。甚至NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入number的值，这种现象被称为“重排序”。只要在某个线程中无法检测到重排序情况（即使在其他线程中可以明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主线程首先写入number，然后在没有同步的情况下写入ready，那么读线程看到的顺序可能与写入的顺序完全相反。 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行春旭进行判断，无法得到正确的结论。 这个看上去像是一个失败的设计，但却能使JVM充分地利用现代多核处理器的强大性能。例如，在缺少同步的情况下，Java内存模型允许编译器对操作顺序进行重排序，并将数值缓存在寄存器中。此外，它还允许CPU对操作顺序进行重排序，并将数值缓存在处理器特定的缓存中。 二、Volatile原理 Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。 在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。 当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。 而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。 当一个变量定义为 volatile 之后，将具备两种特性： 1.保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。 2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。 volatile 性能： volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础之多态]]></title>
    <url>%2F2018%2F09%2F21%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态什么是多态 在面向对象的程序设计语言中,多态是继数据抽象和继承之后的第三种基本特征. 多态通过分离做什么和怎么做,从另一角度将接口和实现类分离开来.它允许将多种类型(同一基类导出的)视为同一类型来处理.多态方法调用允许一种类型表现出与其他类型相似之间的区别,只要他们都是从同一基类导出而来的&#8195;&#8195;&#8195;&#8195;—-《java编程思想》 运行时绑定对应类型的方法 在JAVA中除了static方法和final方法(private方法属于final方法)之外,其他所有的方法都是后期绑定.后期绑定的含义就是在运行时根据对象的类型进行绑定方法.而多态就是基于这种机制而产生的. 接口(interface)就是多态的一种体现 面向接口编程在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的对系统设计人员来讲就不那么重要了；而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程我想就是指按照这种思想来编程吧！ 总结&#8195; 多态意味着”不同的形式”.在面向对象的程序设计中,我门持有从基类继承而来的相同接口,以及使用该接口的不同形式:不同版本的动态绑定方法.]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList原理及实现]]></title>
    <url>%2F2018%2F09%2F21%2FLinkedList%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[LinkedList原理及实现 linkedList是一个双向链表结构,每一个节点中连接了前后节点. 初始化LinkedList,其中包含一个head头节点.头节点与自身连接. LinkedList中维护着一个节点(Node)数据结构. 结构图: 简单实现一个LinkedList:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package com.xjc.demo1;import java.io.Serializable;import java.util.Iterator;/** * @Author:xjc * @Date:2018/9/21 * @Description:双向循环链表 */public class CricluarDoubleLinkedList&lt;T&gt; implements Serializable,Iterable&lt;T&gt; &#123; /** * @Author:xjc * @Date:2018/9/21 * @Description:实现Iterable接口, 就可以使用for-Each循环 */ @Override public Iterator iterator() &#123; return new Iterator() &#123; private volatile int index=0; @Override public boolean hasNext() &#123; return getNode(index)==null?false:true; &#125; @Override public Object next() &#123; return getValue(index++); &#125; &#125;; &#125; private class Node&lt;T&gt;&#123; private T value; private Node&lt;T&gt; prev; private Node&lt;T&gt; prex; &#125; private Node&lt;T&gt; head; private Integer size; public CricluarDoubleLinkedList()&#123; Node&lt;T&gt; node = new Node&lt;&gt;(); head=node; head.prex=head; head.prev=head; this.size=0; &#125; public void insert(T value)&#123; if(size==0) &#123; Node&lt;T&gt; node = new Node&lt;&gt;(); node.prev=head; node.prex=head; node.value=value; head.prex=node; head.prev=node; size++; &#125;else&#123;// 从尾部添加 Node&lt;T&gt; node=new Node&lt;&gt;(); node.prev=head.prev; node.prex=head; node.value=value; head.prev.prex=node; head.prev=node; size++; &#125; &#125; public Node&lt;T&gt; getNode(Integer index)&#123; if(index&gt;size-1) return null;// 判断index是否大于size/2 决定从哪边开始取 if(index&gt;(size&lt;&lt;1))&#123;// 从尾部取 Node cur=head.prev;// 次数 为 size-index-1 为什么要-1 就是因为size永远比节点数大1, (新增节点后size+1 留一个空位) Integer number=size-index-1; for(int i=0;i&lt;number;i++)&#123; cur=cur.prev; &#125; return cur; &#125;else&#123;// 从头部取 Node cur=head.prex; for(int i=0;i&lt;index;i++)&#123; cur=cur.prex; &#125; return cur; &#125; &#125; public T getValue(Integer index)&#123; if(index&gt;size-1||index&lt;0) throw new IndexOutOfBoundsException(); return getNode(index).value; &#125; public Integer getSize() &#123; return size; &#125;&#125; 分析:为什么LinkedList增删比ArrayList快 (可以看到,LinkedList中增也进行了遍历查询) ArrayList中添加代码如下:123456789101112 // 将e添加到ArrayList的指定位置public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( "Index: "+index+", Size: "+size); ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; ensureCapacity(size+1) 的作用是“确认ArrayList的容量，若容量不够，则增加容量。” 真正耗时的操作是 System.arraycopy(elementData, index, elementData, index + 1, size - index); System.arraycopy(elementData, index, elementData, index + 1, size - index); 会移动index之后所有元素即可。这就意味着，ArrayList的add(int index, E element)函数，会引起index之后所有元素的改变！]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList集合原理]]></title>
    <url>%2F2018%2F09%2F20%2FArrayList%E9%9B%86%E5%90%88%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[ArrayList实现及其原理 原理 ArrayList实质上就是一个动态数组,其中维护了一个Object[]对象,ArrayList初始化时其大小为10. 其中维护了一个动态指针size表示当前数组使用大小 当调用add方法添加对象时,会比较实际大小与使用大小. 如果越界,则对object数组进行扩容, 调用Arrays.conpyOf()方法进行扩容 大小为原来的1.5倍 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.xjc.demo1;import java.util.Arrays;public class MyArrayList&lt;T&gt; &#123;private Object[] array;private Integer size;public MyArrayList()&#123; array=new T[10]; this.array=new Object[10]; size=0;&#125;public void add(T t)&#123; //判断大小是否满足 if(size+1&lt;array.length)&#123; array[size++]=t; &#125;else&#123; //扩容 grow(size+1); array[size++]=t; &#125;&#125;public T get(Integer index)&#123; checkIndex(index); return (T) array[index];&#125;public void checkIndex(Integer index)&#123; if(index&gt;size-1||index&lt;0) throw new IndexOutOfBoundsException();&#125;public void grow(Integer min)&#123; Integer old=array.length; Integer newCap=(old&gt;&gt;1)+old; if(newCap-min&lt;0) newCap=min; array= Arrays.copyOf(array,newCap);&#125;public Integer getSize()&#123; return this.size;&#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
      </tags>
  </entry>
</search>
